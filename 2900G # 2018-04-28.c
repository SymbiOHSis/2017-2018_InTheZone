#pragma config(Sensor, dgtl1,  rightenc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  autonLeft,      sensorTouch)
#pragma config(Sensor, dgtl4,  autonThreeMogos, sensorTouch)
#pragma config(Sensor, dgtl5,  autonScoreFirst, sensorTouch)
#pragma config(Sensor, dgtl6,  autonScoreLast, sensorTouch)
#pragma config(Sensor, dgtl7,  autonScore20,   sensorTouch)
#pragma config(Sensor, dgtl11, leftEnc,        sensorQuadEncoder)
#pragma config(Motor,  port1,           gateLeft,      tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           left14,        tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port3,           left2,         tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port4,           left3,         tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port5,           left5,         tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port6,           right5,        tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port7,           right3,        tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port8,           right2,        tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port9,           right14,       tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port10,          gateRight,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"







#include "setDrive_2.1.6.c"
#include "mattsFunctions_1.4.0.c"

#define TICKS_PER_INCH   (360 / (PI * 3.25))

#define GATE_SPEED              127
#define GATE_SPEED_HOLD_DOWN    10
#define GATE_SPEED_HOLD_UP      0

void setGate(int speed) {
    motor[gateLeft]  = speed;
    motor[gateRight] = speed;
}

void pre_auton() {
    setDriveInit();
}






task autonomous() {
    bool left = (bool) SensorValue[autonLeft];
    bool threeMogos = (bool) SensorValue[autonThreeMogos];
    bool scoreFirst = (bool) SensorValue[autonScoreFirst];
    bool scoreLast = (bool) SensorValue[autonScoreLast];
    bool score20 = (bool) SensorValue[autonScore20];

    /*  Commands are
    driveEncoder(speed, sensorPort, target, timeout);
    driveEncoder(speedLeft, speedRight, sensorPort, target, timeout);
    */
    //turn left
    // driveEncoder(-127,127, leftEnc, 12 * TICKS_PER_INCH);
    //turn right 90
    // driveEncoder(127,-127, leftEnc, 12 * TICKS_PER_INCH);
    //Drive foward
    // driveEncoder(127, leftEnc, 12 * TICKS_PER_INCH);
    //reverse
    //driveEncoder(-127, leftEnc, -12 * TICKS_PER_INCH);

    if (left && threeMogos && !scoreFirst && !scoreLast && !score20) {
        ////////////turn right 3 Mogo/////////////////////
        /// drive to mogo
        driveEncoder(127, leftEnc, 42 * TICKS_PER_INCH);
        // turn towards other mogo
        driveEncoder(127,-127, leftEnc, 12 * TICKS_PER_INCH);
        // drive to next mogo
        driveEncoder(127, leftEnc, 38 * TICKS_PER_INCH);
        // put gate down
        motor[gateLeft] = (127);
        motor[gateRight] = (127);
        delay(800);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);

        // go towards third mogo
        driveEncoder(-127,127, leftEnc, -6 * TICKS_PER_INCH);
        driveEncoder(127, leftEnc, 30 * TICKS_PER_INCH);

    }


    else if (!left && threeMogos && !scoreFirst && !scoreLast && !score20) {
        ////////////////////// turn left 3 Mogo/////////////////////
        /////// drive to mogo
        driveEncoder(127, leftEnc, 42 * TICKS_PER_INCH);
        // turn towards other mogo
        driveEncoder(-127,127, leftEnc, -8 * TICKS_PER_INCH);
        // drive to next mogo
        driveEncoder(127, leftEnc, 38 * TICKS_PER_INCH);
        // put gate down
        motor[gateLeft] = (127);
        motor[gateRight] = (127);
        delay(800);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);
        // go towards third mogo
        driveEncoder(127,-127, leftEnc, 6 * TICKS_PER_INCH);
        driveEncoder(127, leftEnc, 30 * TICKS_PER_INCH);
    }


    else if (left && !threeMogos && !scoreFirst && !scoreLast && !score20) {
        //////////turn right then zone///////
        /// drive to mogo
        driveEncoder(127, leftEnc, 42 * TICKS_PER_INCH);
        // turn towards other mogo
        driveEncoder(127,-127, leftEnc, 12 * TICKS_PER_INCH);
        // drive to next mogo
        driveEncoder(127, leftEnc, 38 * TICKS_PER_INCH);
        // put gate down
        motor[gateLeft] = (127);
        motor[gateRight] = (127);
        delay(800);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);
        // go towards opponent zone
        driveEncoder(-127, 127, leftEnc, -11 * TICKS_PER_INCH);
        driveEncoder(127, leftEnc, 41 * TICKS_PER_INCH);
    }


    else if (!left && !threeMogos && !scoreFirst && !scoreLast && !score20){
        /////////turn left then zone)
        /// drive to mogo
        driveEncoder(127, leftEnc, 42 * TICKS_PER_INCH);
        // turn towards other mogo
        driveEncoder(-127,127, leftEnc, -8 * TICKS_PER_INCH);
        // drive to next mogo
        driveEncoder(127, leftEnc, 38 * TICKS_PER_INCH);
        // put gate down
        motor[gateLeft] = (127);
        motor[gateRight] = (127);
        delay(800);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);
        // go towards opponent zone
        driveEncoder(127, -127, leftEnc, 11 * TICKS_PER_INCH);
        driveEncoder(127, leftEnc, 41 * TICKS_PER_INCH);
    }


    else if (left && !threeMogos && scoreFirst && !scoreLast && !score20) {
        //////////start left score then capture///////
        //put gate down & drive to our mogo
        motor[gateLeft] = (127);
        motor[gateRight] = (127);
        delay (300);
        driveEncoder(127, leftEnc, 22 * TICKS_PER_INCH);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);
        driveEncoder(127, leftEnc, 28 * TICKS_PER_INCH);
        // pick mogo up & reverse
        motor[gateLeft] = (-127);
        motor[gateRight] = (-127);
        delay (500);
        driveEncoder(-127, leftEnc, -24 * TICKS_PER_INCH);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);
        driveEncoder(-127, leftEnc, -12 * TICKS_PER_INCH);
        // turn 180 right
        driveEncoder(127, -127, leftEnc, 18 * TICKS_PER_INCH);
        delay (200);
        // drive forward to unload the mogo
        driveEncoder(127, leftEnc, 12 * TICKS_PER_INCH);
        delay(200);
        driveEncoder(127, -127, leftEnc, 6 * TICKS_PER_INCH);
        delay(200);
        driveEncoder(127, leftEnc, 6 * TICKS_PER_INCH);
        motor[gateLeft] = (127);
        motor[gateRight] = (127);
        delay (400);
        driveEncoder(127, leftEnc, 10 * TICKS_PER_INCH);
        motor[gateLeft] = (-127);
        motor[gateRight] = (-127);
        delay (400);
        driveEncoder(-127, leftEnc, -8 * TICKS_PER_INCH);

        driveEncoder(-127, 127, leftEnc, -20 * TICKS_PER_INCH);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);
        driveEncoder(-127, leftEnc, -15 * TICKS_PER_INCH);

        //drive forward capture mogo 1
        driveEncoder(127, leftEnc, 42 * TICKS_PER_INCH);
        // turn towards other mogo
        driveEncoder(127,-127, leftEnc, 8 * TICKS_PER_INCH);
        // drive to next mogo
        driveEncoder(127, leftEnc, 41 * TICKS_PER_INCH);

    }


    else if (!left && !threeMogos && scoreFirst && !scoreLast && !score20){
        ////////// start right score then capture///////
        //put gate down & drive to our mogo
        motor[gateLeft] = (127);
        motor[gateRight] = (127);
        delay (300);
        driveEncoder(127, leftEnc, 22 * TICKS_PER_INCH);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);
        driveEncoder(127, leftEnc, 28 * TICKS_PER_INCH);
        // pick mogo up & reverse
        motor[gateLeft] = (-127);
        motor[gateRight] = (-127);
        delay (500);
        driveEncoder(-127, leftEnc, -24 * TICKS_PER_INCH);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);
        driveEncoder(-127, leftEnc, -12 * TICKS_PER_INCH);
        // turn 180 left
        driveEncoder(-127, 127, leftEnc, -18 * TICKS_PER_INCH);
        delay (200);
        // drive forward to unload the mogo
        driveEncoder(127, leftEnc, 17 * TICKS_PER_INCH);
        delay(200);
        driveEncoder(-127, 127, leftEnc, -6 * TICKS_PER_INCH);
        delay(200);
        driveEncoder(127, leftEnc, 4 * TICKS_PER_INCH);
        motor[gateLeft] = (127);
        motor[gateRight] = (127);
        delay (400);
        driveEncoder(127, leftEnc, 8 * TICKS_PER_INCH);
        motor[gateLeft] = (-127);
        motor[gateRight] = (-127);
        delay (400);
        driveEncoder(-127, leftEnc, -8 * TICKS_PER_INCH);

        driveEncoder(-127, 127, leftEnc, -21 * TICKS_PER_INCH);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);
        driveEncoder(-127, leftEnc, -20 * TICKS_PER_INCH);


        //drive forward to capture mogo 1
        driveEncoder(127, leftEnc, 42 * TICKS_PER_INCH);
        //turn and drive to capture mogo 2
        driveEncoder(-127 ,127, leftEnc, -8 * TICKS_PER_INCH);
        driveEncoder(127 , leftEnc, 41 * TICKS_PER_INCH);
    }


    else if (left && !threeMogos && !scoreFirst && scoreLast && !score20) {
        //////////turn right capture then score///////
        driveEncoder(127, leftEnc, 40 * TICKS_PER_INCH);
        // turn towards other mogo
        driveEncoder(127,-127, leftEnc, 12 * TICKS_PER_INCH);
        // drive to next mogo
        driveEncoder(127, leftEnc, 30 * TICKS_PER_INCH);
        // put gate down
        motor[gateLeft] = (127);
        motor[gateRight] = (127);
        delay(1000);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);

        // turn towards our mogo
        driveEncoder(-127,127, leftEnc, -10 * TICKS_PER_INCH);
        delay(300);
        // drive towards our mogo
        driveEncoder(127, leftEnc, 20 * TICKS_PER_INCH);
        // put gate up
        motor[gateLeft] = (-127);
        motor[gateRight] = (-127);
        delay(2000);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);
        //U Turn to face zone
        driveEncoder(127, -50, leftEnc, 28 * TICKS_PER_INCH);
        //drive forward
        driveEncoder(127, leftEnc, 39* TICKS_PER_INCH);
        //release gate
        motor[gateLeft] = (127);
        motor[gateRight] = (127);
        delay (1500);
        //reverse away
        driveEncoder(-127, leftEnc, -30 * TICKS_PER_INCH);

    }
    else if (!left && !threeMogos && !scoreFirst && scoreLast && !score20){
        driveEncoder(127, leftEnc, 40 * TICKS_PER_INCH);
        // turn towards other mogo
        driveEncoder(127,-127, leftEnc, 12 * TICKS_PER_INCH);
        // drive to next mogo
        driveEncoder(127, leftEnc, 30 * TICKS_PER_INCH);
        // put gate down
        motor[gateLeft] = (127);
        motor[gateRight] = (127);
        delay(1000);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);

        // turn towards our mogo
        driveEncoder(-127,127, leftEnc, -11.8 * TICKS_PER_INCH);
        delay(300);
        // drive towards our mogo
        driveEncoder(127, leftEnc, 20 * TICKS_PER_INCH);
        // put gate up
        motor[gateLeft] = (-127);
        motor[gateRight] = (-127);
        delay(2000);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);
        //U Turn to face zone
        driveEncoder(127, -50, leftEnc, 30 * TICKS_PER_INCH);
        //drive forward
        driveEncoder(127, leftEnc, 39* TICKS_PER_INCH);
        //release gate
        motor[gateLeft] = (127);
        motor[gateRight] = (127);
        delay (1500);
        //reverse away
        driveEncoder(-127, leftEnc, -30 * TICKS_PER_INCH);
    }

    else if (!left && !threeMogos && !scoreFirst && !scoreLast && score20){
        ///////20 pt auton///////

        motor[gateLeft] = (127);
        motor[gateRight] = (127);
        driveEncoder(127, leftEnc, 10 * TICKS_PER_INCH);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);
        driveEncoder(127, leftEnc, 40 * TICKS_PER_INCH);
        // pick mogo up
        motor[gateLeft] = (-127);
        motor[gateRight] = (-127);
        driveEncoder(127, leftEnc, 13 * TICKS_PER_INCH);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);
        //// turn left////
        driveEncoder(-127,127, leftEnc, -13 * TICKS_PER_INCH);
        ///drive to mogo 2
        driveEncoder(127, leftEnc, 48 * TICKS_PER_INCH);
        driveEncoder(-127, 127, leftEnc, -5.5 * TICKS_PER_INCH);
        //drive to mogo 3
        driveEncoder(127, leftEnc, 68 * TICKS_PER_INCH);
        // drive to zone lift down and score
        driveEncoder(-127,127, leftEnc, 12 * TICKS_PER_INCH);
        driveEncoder(127, leftEnc, 50 * TICKS_PER_INCH);
        motor[gateLeft] = (127);
        motor[gateRight] = (127);
        driveEncoder(127, leftEnc, 6 * TICKS_PER_INCH);
        motor[gateLeft] = (-127);
        motor[gateRight] = (-127);
        driveEncoder(-127, leftEnc, -8 * TICKS_PER_INCH);
        motor[gateLeft] = (0);
        motor[gateRight] = (0);
        driveEncoder(-127, leftEnc, -12 * TICKS_PER_INCH);

    }











}

task usercontrol() {
    bool gateIsDown = false;
    while (true) {
        // Only run 50 times a second
        delay(20);
        makeJoystickDeadzones();
    }

        // old drive
        arcadeControl(true);

//// new drive
//  while (true)
//  {{
//    motorReqSlew[left14]  = (vexRT[Ch3] + vexRT[Ch4]);
//    motorReqSlew[left2]  = (vexRT[Ch3] + vexRT[Ch4]);
//    motorReqSlew[left3]  = (vexRT[Ch3] + vexRT[Ch4]);
//    motorReqSlew[left5]  = (vexRT[Ch3] + vexRT[Ch4]);

//    motorReqSlew[right14]  = (vexRT[Ch3] + vexRT[Ch4]);
//    motorReqSlew[right2]  = (vexRT[Ch3] + vexRT[Ch4]);
//    motorReqSlew[right3]  = (vexRT[Ch3] + vexRT[Ch4]);
//    motorReqSlew[right5]  = (vexRT[Ch3] + vexRT[Ch4]);
//}

        // gate
        if (vexRTT[Ch2]) {
            setGate(vexRTT[Ch2]);
            gateIsDown = vexRTT[Ch2] < 0;
        }
        else {
            if (gateIsDown)
                setGate(GATE_SPEED_HOLD_DOWN);
            else
                setGate(GATE_SPEED_HOLD_UP);
        }



    } // while (true)
 // Usercontrol

